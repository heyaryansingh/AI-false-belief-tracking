---
phase: 02-helper-models
plan: 01
type: execute
depends_on: []
files_modified: [src/bsa/agents/helper/__init__.py, src/bsa/agents/helper/base.py]
domain: python
---

<objective>
Create base helper agent interface that all helper models will implement.

Purpose: Establish a common interface for helper agents (reactive, goal-only, belief-sensitive) to ensure consistent interaction patterns with the environment and episode generator.
Output: Base HelperAgent abstract class with methods for observation processing, action planning, and belief tracking hooks.
</objective>

<execution_context>
~/.cursor/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/bsa/common/types.py
@src/bsa/envs/base.py
@src/bsa/agents/human/scripted_human.py
@.planning/phases/01-core-interfaces-gridhouse/01-01-SUMMARY.md
@.planning/phases/01-core-interfaces-gridhouse/01-02-SUMMARY.md
@.planning/phases/01-core-interfaces-gridhouse/01-03-SUMMARY.md

**Established patterns:**
- Type hints throughout (from Phase 1)
- Dataclasses for data structures (ObjectLocation, Observation, EpisodeStep)
- Abstract base classes for interfaces (Environment)
- Agent pattern: plan_action, update_belief methods

**Key decisions:**
- Belief state tracked as Dict[str, ObjectLocation] (matches EpisodeStep format)
- Actions use Action enum
- Observations use Observation dataclass
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create base helper interface</name>
  <files>src/bsa/agents/helper/base.py</files>
  <action>
Create abstract base class `HelperAgent` in `src/bsa/agents/helper/base.py` with the following structure:

1. **Abstract methods:**
   - `plan_action(observation: Observation, episode_step: Optional[EpisodeStep] = None) -> Action`: Plan next action based on observation and optional episode context
   - `update_belief(observation: Observation, human_action: Action, episode_step: Optional[EpisodeStep] = None) -> None`: Update internal belief state (if applicable)
   - `get_belief_state() -> Optional[Dict[str, Any]]`: Return current belief state (None for reactive helper, dict for belief-sensitive)

2. **Optional methods (with default implementations):**
   - `reset() -> None`: Reset helper state (default: no-op)
   - `detect_false_belief(observation: Observation, episode_step: Optional[EpisodeStep] = None) -> bool`: Detect if human has false belief (default: False)

3. **Type hints and docstrings:** Full type hints, comprehensive docstrings explaining each method's purpose, parameters, and return values.

4. **Design considerations:**
   - Interface should be flexible enough for reactive (no belief tracking), goal-only (goal inference only), and belief-sensitive (full particle filter) helpers
   - `episode_step` parameter allows access to true object locations and human beliefs for debugging/evaluation, but helpers should primarily use observations
   - Follow the pattern established by ScriptedHumanAgent (plan_action, update_belief methods)
   - Use ABC from abc module for abstract base class
  </action>
  <verify>python -c "from src.bsa.agents.helper.base import HelperAgent; from abc import ABC; assert issubclass(HelperAgent, ABC); print('Base interface created successfully')"</verify>
  <done>HelperAgent abstract class exists with all required abstract methods, type hints, and docstrings. Can be imported without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Export base interface from module</name>
  <files>src/bsa/agents/helper/__init__.py</files>
  <action>
Create `src/bsa/agents/helper/__init__.py` that exports `HelperAgent` from `base.py`. Follow the pattern used in `src/bsa/agents/human/__init__.py` (simple export, no other logic).
</action>
  <verify>python -c "from src.bsa.agents.helper import HelperAgent; print('Export successful')"</verify>
  <done>HelperAgent can be imported from src.bsa.agents.helper module.</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `python -c "from src.bsa.agents.helper import HelperAgent"` succeeds
- [ ] `python -c "from src.bsa.agents.helper.base import HelperAgent; from abc import ABC; assert issubclass(HelperAgent, ABC)"` passes
- [ ] Type hints are present on all methods
- [ ] Docstrings explain purpose, parameters, and return values
</verification>

<success_criteria>

- Base HelperAgent interface created with abstract methods
- Interface exported from helper module
- Type hints and docstrings complete
- No import errors
- Interface flexible enough for all three helper types (reactive, goal-only, belief-sensitive)
  </success_criteria>

<output>
After completion, create `.planning/phases/02-helper-models/02-01-SUMMARY.md`:

# Phase 2 Plan 1: Base Helper Interface Summary

**Created abstract base class for helper agents**

## Accomplishments

- Created HelperAgent abstract base class with plan_action, update_belief, get_belief_state methods
- Exported interface from helper module
- Established interface pattern for all helper implementations

## Files Created/Modified

- `src/bsa/agents/helper/base.py` - HelperAgent abstract base class
- `src/bsa/agents/helper/__init__.py` - Module exports

## Decisions Made

- Interface includes optional episode_step parameter for debugging/evaluation access
- Abstract methods: plan_action, update_belief, get_belief_state
- Optional methods: reset, detect_false_belief (with defaults)
- Follows ScriptedHumanAgent pattern for consistency

## Issues Encountered

[None or list issues]

## Next Step

Ready for 02-02-PLAN.md (Reactive helper baseline)
</output>
